<!DOCTYPE html>
<html lang="ru">
<head>
<meta charset="UTF-8">
<title>Стратегическая игра: Захват территории</title>
<style>
  .game-board {
    display: grid;
    grid-template-columns: repeat(8, 50px);
    grid-template-rows: repeat(8, 50px);
  }
  .cell {
    width: 50px;
    height: 50px;
    border: 1px solid #000;
    text-align: center;
    line-height: 50px;
  }
  .player { background-color: red; }
  .robot { background-color: blue; }
  .stats {
    margin-bottom: 10px;
  }
  .shop-menu {
    margin-top: 10px;
  }
  .shop-item {
    cursor: pointer;
    padding: 5px;
    border: 1px solid #000;
    display: inline-block;
    margin-right: 5px;
  }
</style>
</head>
<body>

<div class="stats" id="statsDisplay">
  <!-- Статистика ресурсов и влияния будет отображаться здесь -->
</div>

<div id="gameBoard" class="game-board">
  <!-- Игровое поле будет сгенерировано здесь -->
</div>

<div class="shop-menu" id="shopMenu">
  <!-- Меню магазина будет отображаться здесь -->
</div>

<script>
// Инициализация игрового поля и переменных экономики/политики
const boardSize = 8;
const gameBoard = document.getElementById('gameBoard');
const statsDisplay = document.getElementById('statsDisplay');
const shopMenu = document.getElementById('shopMenu');
const resources = { player: 100, robot: 100 }; // Начальные ресурсы
const influence = { player: 0, robot: 0 }; // Начальное влияние
const upgrades = { skipTurnReduction: 50, extraCellPlacement: 100 }; // Стоимость улучшений

for (let i = 0; i < boardSize * boardSize; i++) {
  const cell = document.createElement('div');
  cell.classList.add('cell');
  gameBoard.appendChild(cell);
}

// Функция для отображения статистики
function updateStatsDisplay() {
  statsDisplay.innerHTML = '';
  Object.keys(resources).forEach(player => {
    const playerStats = document.createElement('div');
    playerStats.textContent = player + ': Ресурсы - ' + resources[player] + ', Влияние - ' + influence[player];
    statsDisplay.appendChild(playerStats);
  });
}

// Функция для отображения меню магазина
function updateShopMenu() {
  shopMenu.innerHTML = '';
  Object.keys(upgrades).forEach(upgrade => {
    const shopItem = document.createElement('div');
    shopItem.classList.add('shop-item');
    shopItem.textContent = upgrade + ': ' + upgrades[upgrade] + ' ресурсов';
    shopItem.onclick = function() {
      purchaseUpgrade('player', upgrade);
    };
    shopMenu.appendChild(shopItem);
  });
}

// Логика игры
let currentPlayer = 'player';
const players = ['player', 'robot'];
let skipTurnChance = 0.25; // Изначальный шанс пропуска хода

gameBoard.addEventListener('click', function(event) {
  if (event.target.classList.contains('cell')) {
    makeMove(currentPlayer, event.target);
    switchPlayer();
    robotMoves();
  }
});

function shouldSkipMove() {
  // Возвращает true с вероятностью, равной skipTurnChance
  return Math.random() < skipTurnChance;
}

function switchPlayer() {
  // Передаем ход следующему игроку
  currentPlayer = players[(players.indexOf(currentPlayer) + 1) % players.length];
}

// Функция оценки хода для ИИ
function evaluateMove(cell, playerClass) {
  let score = 0;
  const rowIndex = Math.floor(cell.index / boardSize);
  const colIndex = cell.index % boardSize;
  const directions = [-1, 1, -boardSize, boardSize]; // Вверх, вниз, влево, вправо
  directions.forEach(direction => {
    const neighborIndex = cell.index + direction;
    if (neighborIndex >= 0 && neighborIndex < boardSize * boardSize) {
      const neighborCell = gameBoard.children[neighborIndex];
      if (neighborCell.classList.contains(playerClass)) {
        score++;
      }
    }
  });
  return score;
}

// Обновленная функция robotMoves с оценкой ходов
function robotMoves() {
  const robotClass = 'robot';
  const cells = Array.from(gameBoard.children);
  const emptyCells = cells.filter(cell => !cell.classList.contains(robotClass));
  let bestMove = null;
  let bestScore = -Infinity;
  // Робот выбирает лучший ход на основе оценки
  for (let j = 0; j < emptyCells.length; j++) {
    const currentScore = evaluateMove(emptyCells[j], robotClass);
    if (currentScore > bestScore) {
      bestScore = currentScore;
      bestMove = emptyCells[j];
    }
  }
  if (bestMove) {
    makeMove(robotClass, bestMove);
  }
  currentPlayer = 'player'; // Возвращаем ход игроку
}

function updateEconomy(player) {
  // Увеличиваем ресурсы и влияние за каждую захваченную клетку
  resources[player] += 10;
  influence[player] += 1;
}

function makeMove(player, cell) {
  if (shouldSkipMove()) {
    alert(player + ' пропускает ход!');
  } else {
    if (!cell.classList.contains(player)) {
      players.forEach(p => cell.classList.remove(p));
      cell.classList.add(player);
      updateEconomy(player); // Обновляем экономику после успешного хода
      updateStatsDisplay(); // Обновляем отображение статистики
    }
  }
}

function purchaseUpgrade(player, upgrade) {
  if (resources[player] >= upgrades[upgrade]) {
    resources[player] -= upgrades[upgrade];
    if (upgrade === 'skipTurnReduction') {
      skipTurnChance -= 0.05; // Уменьшаем шанс пропуска хода на 5%
      skipTurnChance = Math.max(skipTurnChance, 0); // Гарантируем, что шанс не уйдет в отрицательное значение
    } else if (upgrade === 'extraCellPlacement') {
      // Позволяем ставить на одну клетку больше
    }
    updateStatsDisplay();
  } else {
    alert('Недостаточно ресурсов для покупки улучшения!');
  }
}

// Инициализация угловых клеток для каждого игрока
const corners = [
  { index: 0, player: 'player' }, // верхний левый угол
  { index: boardSize - 1, player: 'robot' } // верхний правый угол
];
corners.forEach(corner => {
  const cell = gameBoard.children[corner.index];
  cell.classList.add(corner.player);
});

// Вызов функций для обновления статистики и меню магазина при инициализации и после каждого хода
updateStatsDisplay();
updateShopMenu();

// Функции оценки для разных стратегий
function aggressiveStrategy(cell, playerClass) {
  // Агрессивная стратегия: оценивает ходы на основе максимального захвата территории
  let score = 0;
  // ... (логика оценки хода)
  return score;
}

function defensiveStrategy(cell, playerClass) {
  // Оборонительная стратегия: оценивает ходы на основе защиты своих клеток
  let score = 0;
  // ... (логика оценки хода)
  return score;
}

function expansionStrategy(cell, playerClass) {
  // Стратегия расширения: оценивает ходы на основе расширения территории
  let score = 0;
  // ... (логика оценки хода)
  return score;
}

function randomStrategy(cell, playerClass) {
  // Случайная стратегия: выбирает ходы случайным образом
  return Math.random();
}

// Функция для выбора стратегии робота
function chooseRobotStrategy(robotId) {
  switch (robotId) {
    case 1: return aggressiveStrategy;
    case 2: return defensiveStrategy;
    case 3: return expansionStrategy;
    case 4: return randomStrategy;
    // Робот 5 без стратегии, возвращает нулевой счет
    default: return () => 0;
  }
}

// Функция robotMoves обновлена для поддержки множества роботов
function robotMoves(robotId) {
  const robotClass = 'robot' + robotId;
  const strategy = chooseRobotStrategy(robotId);
  const cells = Array.from(gameBoard.children);
  const emptyCells = cells.filter(cell => !cell.classList.contains(robotClass));
  let bestMove = null;
  let bestScore = -Infinity;

  // Робот выбирает лучший ход на основе выбранной стратегии
  for (let j = 0; j < emptyCells.length; j++) {
    const currentScore = strategy(emptyCells[j], robotClass);
    if (currentScore > bestScore) {
      bestScore = currentScore;
      bestMove = emptyCells[j];
    }
  }

  if (bestMove) {
    makeMove(robotClass, bestMove);
  }
}

// ... (остальная часть кода игры)

// Инициализация роботов и их стратегий
for (let i = 1; i <= 5; i++) {
  robotMoves(i);
}

</script>
</body>
</html>


</script>

</body>
</html>

