<!DOCTYPE html>
<html lang="ru">
<head>
<meta charset="UTF-8">
<title>Стратегическая игра: Захват территории</title>
<style>
  .game-board {
    display: grid;
    grid-template-columns: repeat(8, 50px);
    grid-template-rows: repeat(8, 50px);
  }
  .cell {
    width: 50px;
    height: 50px;
    border: 1px solid #000;
    text-align: center;
    line-height: 50px;
  }
  .player { background-color: red; }
  .robot1 { background-color: blue; }
  .robot2 { background-color: green; }
  .robot3 { background-color: yellow; }
  .stats {
    margin-bottom: 10px;
  }
  .shop-menu {
    margin-top: 10px;
  }
  .shop-item {
    cursor: pointer;
    padding: 5px;
    border: 1px solid #000;
    display: inline-block;
    margin-right: 5px;
  }
</style>
</head>
<body>

<div class="stats" id="statsDisplay">
  <!-- Статистика ресурсов и влияния будет отображаться здесь -->
</div>

<div id="gameBoard" class="game-board">
  <!-- Игровое поле будет сгенерировано здесь -->
</div>

<div class="shop-menu" id="shopMenu">
  <!-- Меню магазина будет отображаться здесь -->
</div>

<script>
// Инициализация игрового поля и переменных экономики/политики
const boardSize = 8;
const gameBoard = document.getElementById('gameBoard');
const statsDisplay = document.getElementById('statsDisplay');
const shopMenu = document.getElementById('shopMenu');
const resources = { player: 100, robot1: 100, robot2: 100, robot3: 100 }; // Начальные ресурсы
const influence = { player: 0, robot1: 0, robot2: 0, robot3: 0 }; // Начальное влияние
const upgrades = { skipTurnReduction: 50, extraCellPlacement: 100 }; // Стоимость улучшений

for (let i = 0; i < boardSize * boardSize; i++) {
  const cell = document.createElement('div');
  cell.classList.add('cell');
  gameBoard.appendChild(cell);
}

// Функция для отображения статистики
function updateStatsDisplay() {
  statsDisplay.innerHTML = '';
  Object.keys(resources).forEach(player => {
    const playerStats = document.createElement('div');
    playerStats.textContent = player + ': Ресурсы - ' + resources[player] + ', Влияние - ' + influence[player];
    statsDisplay.appendChild(playerStats);
  });
}

// Функция для отображения меню магазина
function updateShopMenu() {
  shopMenu.innerHTML = '';
  Object.keys(upgrades).forEach(upgrade => {
    const shopItem = document.createElement('div');
    shopItem.classList.add('shop-item');
    shopItem.textContent = upgrade + ': ' + upgrades[upgrade] + ' ресурсов';
    shopItem.onclick = function() {
      purchaseUpgrade('player', upgrade);
    };
    shopMenu.appendChild(shopItem);
  });
}

// Логика игры
let currentPlayer = 'player';
const players = ['player', 'robot1', 'robot2', 'robot3'];
let skipTurnChance = 0.25; // Изначальный шанс пропуска хода

gameBoard.addEventListener('click', function(event) {
  if (event.target.classList.contains('cell')) {
    makeMove(currentPlayer, event.target);
    switchPlayer();
    robotMoves();
  }
});

function shouldSkipMove() {
  // Возвращает true с вероятностью, равной skipTurnChance
  return Math.random() < skipTurnChance;
}

function switchPlayer() {
  // Передаем ход следующему игроку
  currentPlayer = players[(players.indexOf(currentPlayer) + 1) % players.length];
}

// Обновленная функция robotMoves
function robotMoves() {
  // Логика для движения роботов
  for (let i = 1; i < players.length; i++) {
    const robotClass = players[i];
    const cells = Array.from(gameBoard.children);
    const emptyCells = cells.filter(cell => !cell.classList.contains(robotClass));
    // Роботы будут делать по три хода за один ход игрока
    for (let j = 0; j < 3; j++) {
      if (emptyCells.length > 0) {
        const randomCell = emptyCells[Math.floor(Math.random() * emptyCells.length)];
        makeMove(robotClass, randomCell);
      }
    }
  }
  currentPlayer = 'player'; // Возвращаем ход игроку
}

function updateEconomy(player) {
  // Увеличиваем ресурсы и влияние за каждую захваченную клетку
  resources[player] += 10;
  influence[player] += 1;
}

function makeMove(player, cell) {
  if (shouldSkipMove()) {
    alert(player + ' пропускает ход!');
  } else {
    if (!cell.classList.contains(player)) {
      players.forEach(p => cell.classList.remove(p));
      cell.classList.add(player);
      updateEconomy(player); // Обновляем экономику после успешного хода
      updateStatsDisplay(); // Обновляем отображение статистики
    }
  }
}

function purchaseUpgrade(player, upgrade) {
  if (resources[player] >= upgrades[upgrade]) {
    resources[player] -= upgrades[upgrade];
    if (upgrade === 'skipTurnReduction') {
      skipTurnChance -= 0.05; // Уменьшаем шанс пропуска хода на 5%
      skipTurnChance = Math.max(skipTurnChance, 0); // Гарантируем, что шанс не уйдет в отрицательное значение
    } else if (upgrade === 'extraCellPlacement') {
      // Позволяем ставить на одну клетку больше
    }
    updateStatsDisplay();
  } else {
    alert('Недостаточно ресурсов для покупки улучшения!');
  }
}

const corners = [
  { index: 0, player: 'player' }, // верхний левый угол
  { index: boardSize - 1, player: 'robot1' }, // верхний правый угол
  { index: boardSize * (boardSize - 1), player: 'robot2' }, // нижний левый угол
  { index: boardSize * boardSize - 1, player: 'robot3' } // нижний правый угол
];
corners.forEach(corner => {
  const cell = gameBoard.children[corner.index];
  cell.classList.add(corner.player);
});

// Вызовите эти функции для обновления статистики и меню магазина при инициализации и после каждого хода
updateStatsDisplay();
updateShopMenu();

</script>

</body>
</html>

